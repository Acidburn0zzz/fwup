#!/bin/sh

#
# Tests that the "_fwup_root_disk" feature works.  This is a workaround for
# setups that don't have predictable device mappings and allows fwup to figure
# out the mapping for itself.
#
# NOTE: "fwup -d _fwup_root_disk" is untested since it would be destructive to
# the machine running the regression tests.
#

. ./common.sh

case $HOST_OS in
    Darwin|Windows)
        # Not implemented due to not expecting it to be needed.
        exit 0
        ;;
    FreeBSD|NetBSD|OpenBSD|DragonFly)
        # find_rdev doesn't work due to stat calls.
        exit 0
        ;;
    *)
        ;;
esac

if [ "$CC" = "x86_64-w64-mingw32-gcc" -o "$MODE" = "windows" ]; then
    # Try to detect the cross-compile for Windows case since
    # this really doesn't make sense for this test.
    exit 0
fi

# Figure out where the root filesystem is. Sadly, we can't depend on Busybox's
# rdev, since it's not compiled into Busybox on Linux.
find_rdev() {
    WANT=$(stat / -c "%04D")
    FILES=$(find /dev)
    for FILE in $FILES; do
        GOT=$(stat $FILE -c "%02t%02T")
        if [ $WANT = $GOT ]; then
            echo $FILE
            break
        fi
    done
}
RDEV=$(find_rdev)
if [ -z $RDEV ]; then
    echo "The root filesystem doesn't map to one device file, so can't test for rdev"
    # Skip the test for these systems
    exit 0
fi
RDISK=$(echo $RDEV | sed 's/[0-9]\+$//')

# Test the -Z option to dump the root device since we can't safely test "-d _fwup_root_disk"
DASH_Z=$($FWUP_CREATE -Z)
if [ "$DASH_Z" != "$RDISK" ]; then
    echo "fwup -Z returned '$DASH_Z', but was expecting '$RDISK'"
    exit 1
fi

